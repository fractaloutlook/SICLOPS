{
  "version": "v1.0",
  "runNumber": 9,
  "startedAt": "2026-01-06T11:20:53.119Z",
  "lastUpdated": "2026-01-06T19:55:59.592Z",
  "currentPhase": "code_review",
  "discussionSummary": {
    "topic": "Framework Development Priorities",
    "keyDecisions": [],
    "consensusReached": true,
    "consensusSignals": {
      "Sam": "building",
      "Jordan": "disagree",
      "Pierre": "building",
      "Alex": "disagree",
      "Morgan": "disagree"
    }
  },
  "codeChanges": [
    {
      "file": "src/memory/shared-cache.ts",
      "action": "create",
      "content": "/**\n * SharedMemoryCache - Three-Bucket LRU Cache for Agent Context Sharing\n * \n * Purpose: Enable agents to share context across runs with token-aware caching,\n * preventing memory overflow while maintaining decision context.\n * \n * Design:\n * - Three classification buckets: transient, decision, sensitive\n * - LRU (Least Recently Used) eviction within each bucket\n * - TTL (Time To Live) per bucket type\n * - 50k token hard cap total\n * - Sensitive bucket: 10% (~5k tokens), never auto-evicts\n * - Comprehensive eviction logging for observability\n */\n\nimport { EventEmitter } from 'events';\n\ninterface CacheEntry<T> {\n  key: string;\n  value: T;\n  bucket: BucketType;\n  tokens: number;\n  createdAt: number;\n  lastAccessedAt: number;\n  reason?: string; // Documentation only - NEVER used for eviction logic\n}\n\ntype BucketType = 'transient' | 'decision' | 'sensitive';\n\ninterface BucketConfig {\n  maxTokens: number;\n  ttlMs: number;\n  autoEvict: boolean;\n}\n\ninterface CacheStats {\n  totalTokens: number;\n  entriesByBucket: Record<BucketType, number>;\n  tokensByBucket: Record<BucketType, number>;\n  hitRate: number;\n  evictionLog: Array<{\n    timestamp: number;\n    key: string;\n    bucket: BucketType;\n    reason: string;\n    tokensFreed: number;\n  }>;\n}\n\nexport class SharedMemoryCache extends EventEmitter {\n  private cache: Map<string, CacheEntry<any>> = new Map();\n  private bucketConfigs: Record<BucketType, BucketConfig>;\n  private totalMaxTokens = 50000;\n  private stats = {\n    hits: 0,\n    misses: 0,\n    evictions: 0,\n    evictionLog: [] as Array<{\n      timestamp: number;\n      key: string;\n      bucket: BucketType;\n      reason: string;\n      tokensFreed: number;\n    }>,\n  };\n\n  constructor() {\n    super();\n\n    // Bucket configuration with TTLs and capacity\n    this.bucketConfigs = {\n      transient: {\n        maxTokens: 20000, // 40% of total\n        ttlMs: 3600000, // 1 hour\n        autoEvict: true,\n      },\n      decision: {\n        maxTokens: 25000, // 50% of total\n        ttlMs: 86400000, // 24 hours\n        autoEvict: true,\n      },\n      sensitive: {\n        maxTokens: 5000, // 10% of total\n        ttlMs: 604800000, // 7 days\n        autoEvict: false, // Manual eviction only\n      },\n    };\n  }\n\n  /**\n   * Store a value in the cache with optional reason for documentation.\n   * Reason field is strictly observational - never influences eviction logic.\n   */\n  store<T>(\n    key: string,\n    value: T,\n    bucket: BucketType,\n    reason?: string\n  ): void {\n    const tokens = this.estimateTokens(value);\n\n    if (tokens > this.bucketConfigs[bucket].maxTokens) {\n      const error = `Value exceeds bucket capacity: ${tokens} tokens > ${this.bucketConfigs[bucket].maxTokens} max`;\n      this.log('STORE_FAILED', { key, bucket, reason, error, tokens });\n      throw new Error(error);\n    }\n\n    // Remove existing entry if present\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    }\n\n    // Evict if necessary to make room\n    this.ensureCapacity(bucket, tokens);\n\n    const entry: CacheEntry<T> = {\n      key,\n      value,\n      bucket,\n      tokens,\n      createdAt: Date.now(),\n      lastAccessedAt: Date.now(),\n      reason,\n    };\n\n    this.cache.set(key, entry);\n    this.log('STORE', { key, bucket, reason, tokens });\n  }\n\n  /**\n   * Retrieve a value from the cache.\n   * Updates LRU timestamp on successful retrieval.\n   */\n  retrieve<T>(key: string): T | null {\n    const entry = this.cache.get(key);\n\n    if (!entry) {\n      this.stats.misses++;\n      this.log('RETRIEVE_MISS', { key });\n      return null;\n    }\n\n    // Check TTL\n    const age = Date.now() - entry.createdAt;\n    const config = this.bucketConfigs[entry.bucket];\n    if (age > config.ttlMs) {\n      this.cache.delete(key);\n      this.log('RETRIEVE_EXPIRED', {\n        key,\n        bucket: entry.bucket,\n        ageMs: age,\n        ttlMs: config.ttlMs,\n        tokens: entry.tokens,\n      });\n      this.stats.misses++;\n      return null;\n    }\n\n    // Update LRU timestamp\n    entry.lastAccessedAt = Date.now();\n    this.stats.hits++;\n    this.log('RETRIEVE_HIT', { key, bucket: entry.bucket, ageMs: age });\n\n    return entry.value as T;\n  }\n\n  /**\n   * Manually evict a key from the cache.\n   * Sensitive bucket requires explicit eviction.\n   */\n  evict(key: string): boolean {\n    const entry = this.cache.get(key);\n\n    if (!entry) {\n      this.log('EVICT_NOT_FOUND', { key });\n      return false;\n    }\n\n    this.cache.delete(key);\n    this.stats.evictions++;\n    this.recordEviction(\n      key,\n      entry.bucket,\n      'manual_eviction',\n      entry.tokens\n    );\n\n    return true;\n  }\n\n  /**\n   * Get cache statistics and eviction history.\n   */\n  getStats(): CacheStats {\n    const stats: CacheStats = {\n      totalTokens: 0,\n      entriesByBucket: {\n        transient: 0,\n        decision: 0,\n        sensitive: 0,\n      },\n      tokensByBucket: {\n        transient: 0,\n        decision: 0,\n        sensitive: 0,\n      },\n      hitRate: this.stats.hits / (this.stats.hits + this.stats.misses) || 0,\n      evictionLog: this.stats.evictionLog,\n    };\n\n    for (const entry of this.cache.values()) {\n      stats.totalTokens += entry.tokens;\n      stats.entriesByBucket[entry.bucket]++;\n      stats.tokensByBucket[entry.bucket] += entry.tokens;\n    }\n\n    return stats;\n  }\n\n  /**\n   * PRIVATE: Ensure bucket has capacity for incoming value.\n   * Uses LRU eviction strategy - removes least recently used items first.\n   * Never auto-evicts from sensitive bucket.\n   */\n  private ensureCapacity(bucket: BucketType, requiredTokens: number): void {\n    const config = this.bucketConfigs[bucket];\n    const bucketEntries = Array.from(this.cache.values()).filter(\n      (e) => e.bucket === bucket\n    );\n\n    let bucketTokens = bucketEntries.reduce((sum, e) => sum + e.tokens, 0);\n\n    // Check if we need to evict from this bucket\n    if (bucketTokens + requiredTokens > config.maxTokens) {\n      if (!config.autoEvict && bucket === 'sensitive') {\n        throw new Error(\n          `Sensitive bucket full: ${bucketTokens} + ${requiredTokens} > ${config.maxTokens}`\n        );\n      }\n\n      // Sort by LRU (least recently used first)\n      bucketEntries.sort(\n        (a, b) => a.lastAccessedAt - b.lastAccessedAt\n      );\n\n      // Evict until we have space\n      for (const entry of bucketEntries) {\n        if (bucketTokens + requiredTokens <= config.maxTokens) break;\n\n        this.cache.delete(entry.key);\n        bucketTokens -= entry.tokens;\n        this.stats.evictions++;\n        this.recordEviction(\n          entry.key,\n          bucket,\n          'lru_eviction_bucket_full',\n          entry.tokens\n        );\n      }\n    }\n\n    // Check total cache capacity\n    const totalTokens = Array.from(this.cache.values()).reduce(\n      (sum, e) => sum + e.tokens,\n      0\n    );\n\n    if (totalTokens + requiredTokens > this.totalMaxTokens) {\n      // Aggressive eviction: remove LRU items from non-sensitive buckets\n      const evictableEntries = Array.from(this.cache.values())\n        .filter((e) => e.bucket !== 'sensitive')\n        .sort((a, b) => a.lastAccessedAt - b.lastAccessedAt);\n\n      let currentTotal = totalTokens;\n      for (const entry of evictableEntries) {\n        if (currentTotal + requiredTokens <= this.totalMaxTokens) break;\n\n        this.cache.delete(entry.key);\n        currentTotal -= entry.tokens;\n        this.stats.evictions++;\n        this.recordEviction(\n          entry.key,\n          entry.bucket,\n          'lru_eviction_total_capacity',\n          entry.tokens\n        );\n      }\n\n      // Last resort: check if still over capacity\n      if (currentTotal + requiredTokens > this.totalMaxTokens) {\n        throw new Error(\n          `Cannot allocate ${requiredTokens} tokens. Total capacity exceeded.`\n        );\n      }\n    }\n  }\n\n  /**\n   * PRIVATE: Record eviction event for observability.\n   */\n  private recordEviction(\n    key: string,\n    bucket: BucketType,\n    reason: string,\n    tokens: number\n  ): void {\n    const entry = {\n      timestamp: Date.now(),\n      key,\n      bucket,\n      reason,\n      tokensFreed: tokens,\n    };\n\n    this.stats.evictionLog.push(entry);\n    // Keep last 1000 evictions in memory\n    if (this.stats.evictionLog.length > 1000) {\n      this.stats.evictionLog.shift();\n    }\n\n    this.log('EVICTION_RECORDED', entry);\n  }\n\n  /**\n   * PRIVATE: Estimate token count for a value.\n   * Rough heuristic: ~1 token per 4 characters for strings,\n   * recursive estimation for objects.\n   */\n  private estimateTokens(value: any): number {\n    if (typeof value === 'string') {\n      return Math.ceil(value.length / 4);\n    }\n\n    if (typeof value === 'number') {\n      return 1;\n    }\n\n    if (typeof value === 'boolean') {\n      return 1;\n    }\n\n    if (Array.isArray(value)) {\n      return value.reduce((sum, item) => sum + this.estimateTokens(item), 0);\n    }\n\n    if (typeof value === 'object' && value !== null) {\n      return Object.values(value).reduce(\n        (sum, v) => sum + this.estimateTokens(v),\n        0\n      );\n    }\n\n    return 1;\n  }\n\n  /**\n   * PRIVATE: Emit observability logs.\n   */\n  private log(event: string, data: any): void {\n    const logEntry = {\n      timestamp: new Date().toISOString(),\n      event,\n      data,\n    };\n\n    console.log(`[SharedMemoryCache] ${JSON.stringify(logEntry)}`);\n    this.emit('log', logEntry);\n  }\n}\n\nexport default SharedMemoryCache;\n",
      "appliedAt": "2026-01-06T16:37:53.386Z",
      "validatedAt": "2026-01-06T16:37:53.386Z",
      "status": "validated"
    },
    {
      "file": "src/memory/shared-cache.ts",
      "action": "edit",
      "content": "import { EventEmitter } from 'events';\n\n/**\n * Structured logging for cache operations.\n * Every operation MUST emit one of these events for observability.\n */\ninterface CacheEvent {\n  timestamp: number;\n  operation: 'store' | 'retrieve' | 'evict' | 'expire';\n  key: string;\n  bucket: 'transient' | 'decision' | 'sensitive';\n  tokenCount?: number;\n  reason?: string; // Write-time documentation only, never used in logic\n  totalCacheTokens: number;\n  evictedKey?: string; // If this operation triggered eviction\n  evictionReason?: string; // 'lru' | 'ttl' | 'overflow'\n}\n\ninterface CacheEntry {\n  value: string;\n  bucket: 'transient' | 'decision' | 'sensitive';\n  tokenCount: number;\n  storedAt: number;\n  lastAccessedAt: number;\n  reason?: string;\n}\n\n/**\n * SharedMemoryCache: Three-bucket LRU with token-aware eviction.\n * \n * CRITICAL DESIGN CONSTRAINTS:\n * 1. Reason field is documentation-only - NEVER influence eviction logic with it\n * 2. Sensitive bucket (10% capacity) never auto-evicts - explicit evict() only\n * 3. 50k token hard cap enforced across all buckets\n * 4. All operations must emit CacheEvent for observability\n * 5. TTL enforcement happens at access time, not via background tasks\n */\nexport class SharedMemoryCache extends EventEmitter {\n  private cache: Map<string, CacheEntry> = new Map();\n  private bucketTokenCounts: {\n    transient: number;\n    decision: number;\n    sensitive: number;\n  } = { transient: 0, decision: 0, sensitive: 0 };\n\n  private readonly TOTAL_CAPACITY = 50000; // tokens\n  private readonly SENSITIVE_CAPACITY = 5000; // 10% of total\n  private readonly DECISION_CAPACITY = 22500; // 45% of total\n  private readonly TRANSIENT_CAPACITY = 22500; // 45% of total\n\n  private readonly TTL_MS: Record<string, number> = {\n    transient: 5 * 60 * 1000, // 5 minutes\n    decision: 60 * 60 * 1000, // 1 hour\n    sensitive: 24 * 60 * 60 * 1000, // 24 hours\n  };\n\n  constructor() {\n    super();\n  }\n\n  /**\n   * Store a value in the cache.\n   * @param key Unique identifier\n   * @param value Content to cache\n   * @param bucket Classification: transient|decision|sensitive\n   * @param reason Optional documentation of why this was stored\n   * @returns true if stored, false if rejected (e.g., sensitive bucket full)\n   */\n  store(\n    key: string,\n    value: string,\n    bucket: 'transient' | 'decision' | 'sensitive',\n    reason?: string\n  ): boolean {\n    const tokenCount = this.estimateTokens(value);\n\n    // Check bucket capacity hard limits\n    if (bucket === 'sensitive' && this.bucketTokenCounts.sensitive + tokenCount > this.SENSITIVE_CAPACITY) {\n      this.emitEvent({\n        timestamp: Date.now(),\n        operation: 'store',\n        key,\n        bucket,\n        tokenCount,\n        reason,\n        totalCacheTokens: this.getTotalTokens(),\n        evictionReason: 'overflow',\n      });\n      return false; // Sensitive bucket rejects overflow\n    }\n\n    // Remove old entry if exists\n    if (this.cache.has(key)) {\n      const oldEntry = this.cache.get(key)!;\n      this.bucketTokenCounts[oldEntry.bucket] -= oldEntry.tokenCount;\n    }\n\n    // Try to make space if total exceeds capacity\n    const totalAfterInsert = this.getTotalTokens() + tokenCount;\n    if (totalAfterInsert > this.TOTAL_CAPACITY) {\n      this.evictToMakeSpace(tokenCount, bucket);\n    }\n\n    // Store the entry\n    this.cache.set(key, {\n      value,\n      bucket,\n      tokenCount,\n      storedAt: Date.now(),\n      lastAccessedAt: Date.now(),\n      reason,\n    });\n    this.bucketTokenCounts[bucket] += tokenCount;\n\n    this.emitEvent({\n      timestamp: Date.now(),\n      operation: 'store',\n      key,\n      bucket,\n      tokenCount,\n      reason,\n      totalCacheTokens: this.getTotalTokens(),\n    });\n\n    return true;\n  }\n\n  /**\n   * Retrieve a value from cache.\n   * Returns null if expired, not found, or error during retrieval.\n   * Updates lastAccessedAt for LRU tracking.\n   */\n  retrieve(key: string): string | null {\n    const entry = this.cache.get(key);\n\n    if (!entry) {\n      this.emitEvent({\n        timestamp: Date.now(),\n        operation: 'retrieve',\n        key,\n        bucket: 'transient', // dummy for event\n        totalCacheTokens: this.getTotalTokens(),\n      });\n      return null;\n    }\n\n    // Check TTL\n    const ageMs = Date.now() - entry.storedAt;\n    const ttl = this.TTL_MS[entry.bucket];\n    if (ageMs > ttl) {\n      this.emitEvent({\n        timestamp: Date.now(),\n        operation: 'expire',\n        key,\n        bucket: entry.bucket,\n        tokenCount: entry.tokenCount,\n        evictionReason: 'ttl',\n        totalCacheTokens: this.getTotalTokens(),\n      });\n      this.bucketTokenCounts[entry.bucket] -= entry.tokenCount;\n      this.cache.delete(key);\n      return null;\n    }\n\n    // Update access time for LRU\n    entry.lastAccessedAt = Date.now();\n\n    this.emitEvent({\n      timestamp: Date.now(),\n      operation: 'retrieve',\n      key,\n      bucket: entry.bucket,\n      tokenCount: entry.tokenCount,\n      totalCacheTokens: this.getTotalTokens(),\n    });\n\n    return entry.value;\n  }\n\n  /**\n   * Explicitly evict a key from cache.\n   * Works on any bucket, including sensitive.\n   */\n  evict(key: string): boolean {\n    const entry = this.cache.get(key);\n    if (!entry) {\n      return false;\n    }\n\n    this.bucketTokenCounts[entry.bucket] -= entry.tokenCount;\n    this.cache.delete(key);\n\n    this.emitEvent({\n      timestamp: Date.now(),\n      operation: 'evict',\n      key,\n      bucket: entry.bucket,\n      tokenCount: entry.tokenCount,\n      evictedKey: key,\n      evictionReason: 'explicit',\n      totalCacheTokens: this.getTotalTokens(),\n    });\n\n    return true;\n  }\n\n  /**\n   * Get cache statistics for monitoring.\n   */\n  getStats() {\n    return {\n      totalTokens: this.getTotalTokens(),\n      capacity: this.TOTAL_CAPACITY,\n      utilizationPercent: (this.getTotalTokens() / this.TOTAL_CAPACITY) * 100,\n      buckets: {\n        transient: {\n          tokens: this.bucketTokenCounts.transient,\n          capacity: this.TRANSIENT_CAPACITY,\n          entries: Array.from(this.cache.values()).filter(e => e.bucket === 'transient').length,\n        },\n        decision: {\n          tokens: this.bucketTokenCounts.decision,\n          capacity: this.DECISION_CAPACITY,\n          entries: Array.from(this.cache.values()).filter(e => e.bucket === 'decision').length,\n        },\n        sensitive: {\n          tokens: this.bucketTokenCounts.sensitive,\n          capacity: this.SENSITIVE_CAPACITY,\n          entries: Array.from(this.cache.values()).filter(e => e.bucket === 'sensitive').length,\n        },\n      },\n      totalEntries: this.cache.size,\n    };\n  }\n\n  // ============ PRIVATE HELPERS ============\n\n  /**\n   * Estimate token count for a string.\n   * Rule of thumb: ~4 chars per token (conservative).\n   */\n  private estimateTokens(value: string): number {\n    return Math.ceil(value.length / 4);\n  }\n\n  /**\n   * Get total tokens across all buckets.\n   */\n  private getTotalTokens(): number {\n    return (\n      this.bucketTokenCounts.transient +\n      this.bucketTokenCounts.decision +\n      this.bucketTokenCounts.sensitive\n    );\n  }\n\n  /**\n   * Evict least recently used entries to make space.\n   * NEVER touches sensitive bucket unless it's the source.\n   * Strategy: evict from requesting bucket first, then decision, then transient.\n   */\n  private evictToMakeSpace(\n    neededTokens: number,\n    requestingBucket: 'transient' | 'decision' | 'sensitive'\n  ): void {\n    let freedTokens = 0;\n\n    // Priority: evict from requesting bucket's own LRU first\n    const evictionOrder = this.getEvictionOrder(requestingBucket);\n\n    for (const bucket of evictionOrder) {\n      if (freedTokens >= neededTokens) break;\n      if (bucket === 'sensitive') continue; // NEVER auto-evict sensitive\n\n      const candidates = Array.from(this.cache.values())\n        .filter(e => e.bucket === bucket)\n        .sort((a, b) => a.lastAccessedAt - b.lastAccessedAt);\n\n      for (const candidate of candidates) {\n        if (freedTokens >= neededTokens) break;\n\n        const candidateKey = Array.from(this.cache.entries()).find(\n          ([, v]) => v === candidate\n        )?.[0];\n\n        if (candidateKey) {\n          this.bucketTokenCounts[candidate.bucket] -= candidate.tokenCount;\n          this.cache.delete(candidateKey);\n          freedTokens += candidate.tokenCount;\n\n          this.emitEvent({\n            timestamp: Date.now(),\n            operation: 'evict',\n            key: candidateKey,\n            bucket: candidate.bucket,\n            tokenCount: candidate.tokenCount,\n            evictedKey: candidateKey,\n            evictionReason: 'lru',\n            totalCacheTokens: this.getTotalTokens(),\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Determine eviction order based on requesting bucket.\n   * Transient -> Decision -> Sensitive (but sensitive never auto-evicts).\n   */\n  private getEvictionOrder(\n    bucket: 'transient' | 'decision' | 'sensitive'\n  ): Array<'transient' | 'decision' | 'sensitive'> {\n    if (bucket === 'transient') {\n      return ['transient', 'decision']; // Don't touch sensitive\n    }\n    if (bucket === 'decision') {\n      return ['decision', 'transient']; // Try own bucket first\n    }\n    // Sensitive requesting space - evict from decision/transient only\n    return ['decision', 'transient'];\n  }\n\n  /**\n   * Emit structured cache event for observability.\n   */\n  private emitEvent(event: CacheEvent): void {\n    this.emit('cache-event', event);\n    // Also log for immediate visibility during development\n    console.log(\n      `[CACHE] ${event.operation.toUpperCase()} | bucket=${event.bucket} | key=${event.key} | tokens=${event.tokenCount ?? 'N/A'} | total=${event.totalCacheTokens} | ${event.evictionReason ? `evicted: ${event.evictionReason}` : ''}`\n    );\n  }\n}\n",
      "appliedAt": null,
      "validatedAt": null,
      "status": "failed",
      "validationError": "src/memory/shared-cache.ts(347,7): error TS2322: Type 'unknown' is not assignable to type 'number'.\r\nsrc/memory/shared-cache.ts(348,21): error TS18046: 'sum' is of type 'unknown'.\r\n"
    },
    {
      "file": "src/memory/shared-cache.ts",
      "action": "edit",
      "content": "/**\n * SharedMemoryCache: Three-bucket LRU cache for agent context sharing\n * \n * Design constraints (DO NOT violate):\n * - Reason field is DOCUMENTATION ONLY, never used in eviction logic\n * - Sensitive bucket never auto-evicts (hard stop)\n * - 50k token hard cap total\n * - Conservative token estimation: 4 chars = 1 token\n */\n\ninterface CacheEntry<T> {\n  value: T;\n  bucket: 'transient' | 'decision' | 'sensitive';\n  createdAt: number;\n  lastAccessedAt: number;\n  reason?: string; // DOCUMENTATION ONLY - never used for decisions\n  tokenCount: number;\n}\n\ninterface CacheEvent {\n  timestamp: number;\n  operation: 'store' | 'retrieve' | 'evict' | 'expire';\n  bucket: 'transient' | 'decision' | 'sensitive';\n  key: string;\n  success: boolean;\n  tokensAffected: number;\n  totalCacheTokens: number;\n  evictionReason?: string; // Why was this entry removed?\n}\n\ninterface CacheStats {\n  totalTokens: number;\n  byBucket: Record<'transient' | 'decision' | 'sensitive', { tokens: number; entries: number }>;\n  evictionCount: number;\n  hitRate: number;\n}\n\nexport class SharedMemoryCache {\n  private cache = new Map<string, CacheEntry<any>>();\n  private eventLog: CacheEvent[] = [];\n  private stats = { hits: 0, misses: 0, evictions: 0 };\n\n  // Configuration\n  private readonly MAX_TOTAL_TOKENS = 50000;\n  private readonly BUCKET_SIZES = {\n    transient: 0.45 * this.MAX_TOTAL_TOKENS,   // 22.5k\n    decision: 0.45 * this.MAX_TOTAL_TOKENS,    // 22.5k\n    sensitive: 0.10 * this.MAX_TOTAL_TOKENS,   // 5k - NEVER auto-evicts\n  };\n  private readonly TTL_MS = {\n    transient: 1 * 60 * 60 * 1000,   // 1 hour\n    decision: 24 * 60 * 60 * 1000,   // 24 hours\n    sensitive: Infinity,             // never expires\n  };\n\n  /**\n   * Store a value in the cache\n   * @param key - unique identifier\n   * @param value - data to store\n   * @param bucket - classification: transient/decision/sensitive\n   * @param reason - optional documentation (never used for eviction logic)\n   */\n  store<T>(key: string, value: T, bucket: 'transient' | 'decision' | 'sensitive', reason?: string): boolean {\n    const tokenCount = this.estimateTokens(JSON.stringify(value));\n\n    // SAFETY: Sensitive bucket cannot be evicted to make room\n    if (bucket !== 'sensitive') {\n      this.ensureCapacity(tokenCount, bucket);\n    } else {\n      // Sensitive bucket has its own hard limit - respect it\n      const sensitiveTokens = this.getTokensByBucket('sensitive');\n      if (sensitiveTokens + tokenCount > this.BUCKET_SIZES.sensitive) {\n        this.emitEvent('store', bucket, key, false, 0, `Sensitive bucket at capacity (${sensitiveTokens}/${this.BUCKET_SIZES.sensitive} tokens)`);\n        return false; // DO NOT auto-evict from sensitive\n      }\n    }\n\n    // Remove old entry if exists\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    }\n\n    this.cache.set(key, {\n      value,\n      bucket,\n      createdAt: Date.now(),\n      lastAccessedAt: Date.now(),\n      reason, // Documentation only\n      tokenCount,\n    });\n\n    this.emitEvent('store', bucket, key, true, tokenCount);\n    return true;\n  }\n\n  /**\n   * Retrieve a value from the cache\n   * Returns null if not found, expired, or bucket is unknown\n   */\n  retrieve<T>(key: string): T | null {\n    const entry = this.cache.get(key);\n    if (!entry) {\n      this.stats.misses++;\n      this.emitEvent('retrieve', 'transient', key, false, 0);\n      return null;\n    }\n\n    // Check TTL\n    const ttl = this.TTL_MS[entry.bucket];\n    if (ttl !== Infinity && Date.now() - entry.createdAt > ttl) {\n      this.cache.delete(key);\n      this.stats.evictions++;\n      this.emitEvent('expire', entry.bucket, key, true, entry.tokenCount, `TTL exceeded for ${entry.bucket}`);\n      return null;\n    }\n\n    // Update access time\n    entry.lastAccessedAt = Date.now();\n    this.stats.hits++;\n    this.emitEvent('retrieve', entry.bucket, key, true, entry.tokenCount);\n    return entry.value as T;\n  }\n\n  /**\n   * Manually evict a key\n   */\n  evict(key: string): boolean {\n    const entry = this.cache.get(key);\n    if (!entry) return false;\n\n    // SAFETY: Cannot manually evict from sensitive bucket\n    if (entry.bucket === 'sensitive') {\n      this.emitEvent('evict', entry.bucket, key, false, 0, 'Cannot evict from sensitive bucket');\n      return false;\n    }\n\n    this.cache.delete(key);\n    this.stats.evictions++;\n    this.emitEvent('evict', entry.bucket, key, true, entry.tokenCount, 'Manual eviction');\n    return true;\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getStats(): CacheStats {\n    const byBucket = {\n      transient: { tokens: 0, entries: 0 },\n      decision: { tokens: 0, entries: 0 },\n      sensitive: { tokens: 0, entries: 0 },\n    };\n\n    this.cache.forEach((entry) => {\n      byBucket[entry.bucket].tokens += entry.tokenCount;\n      byBucket[entry.bucket].entries += 1;\n    });\n\n    const totalTokens = Object.values(byBucket).reduce((sum, b) => sum + b.tokens, 0);\n    const totalRequests = this.stats.hits + this.stats.misses;\n    const hitRate = totalRequests > 0 ? this.stats.hits / totalRequests : 0;\n\n    return {\n      totalTokens,\n      byBucket,\n      evictionCount: this.stats.evictions,\n      hitRate,\n    };\n  }\n\n  /**\n   * Get recent events for observability\n   */\n  getRecentEvents(limit: number = 100): CacheEvent[] {\n    return this.eventLog.slice(-limit);\n  }\n\n  // ─────────────────────────────────────────────────────────────\n  // PRIVATE: Implementation details\n  // ─────────────────────────────────────────────────────────────\n\n  private estimateTokens(text: string): number {\n    // Conservative: 4 characters = 1 token\n    return Math.ceil(text.length / 4);\n  }\n\n  private getTokensByBucket(bucket: 'transient' | 'decision' | 'sensitive'): number {\n    let total = 0;\n    this.cache.forEach((entry) => {\n      if (entry.bucket === bucket) total += entry.tokenCount;\n    });\n    return total;\n  }\n\n  private ensureCapacity(tokensNeeded: number, bucket: 'transient' | 'decision' | 'sensitive'): void {\n    const totalTokens = Array.from(this.cache.values()).reduce((sum, e) => sum + e.tokenCount, 0);\n    const bucketTokens = this.getTokensByBucket(bucket);\n    const bucketCapacity = this.BUCKET_SIZES[bucket];\n\n    // If adding this entry would exceed bucket capacity, evict from this bucket first\n    if (bucketTokens + tokensNeeded > bucketCapacity) {\n      this.evictLRUFromBucket(bucket, tokensNeeded);\n    }\n\n    // If adding this entry would exceed total capacity, evict from other buckets\n    if (totalTokens + tokensNeeded > this.MAX_TOTAL_TOKENS) {\n      this.evictLRUGlobal(tokensNeeded);\n    }\n  }\n\n  private evictLRUFromBucket(bucket: 'transient' | 'decision' | 'sensitive', tokensNeeded: number): void {\n    const entries = Array.from(this.cache.entries())\n      .filter(([, e]) => e.bucket === bucket)\n      .sort((a, b) => a[1].lastAccessedAt - b[1].lastAccessedAt);\n\n    let freed = 0;\n    for (const [key, entry] of entries) {\n      if (freed >= tokensNeeded) break;\n      this.cache.delete(key);\n      this.stats.evictions++;\n      freed += entry.tokenCount;\n      this.emitEvent('evict', bucket, key, true, entry.tokenCount, `LRU eviction from ${bucket} bucket`);\n    }\n  }\n\n  private evictLRUGlobal(tokensNeeded: number): void {\n    // Eviction order: own bucket → decision → transient (NEVER sensitive)\n    const entries = Array.from(this.cache.entries())\n      .filter(([, e]) => e.bucket !== 'sensitive')\n      .sort((a, b) => {\n        // Sort by bucket priority, then by LRU within bucket\n        const bucketOrder = { transient: 0, decision: 1, sensitive: 2 };\n        const bucketDiff = bucketOrder[a[1].bucket] - bucketOrder[b[1].bucket];\n        if (bucketDiff !== 0) return bucketDiff;\n        return a[1].lastAccessedAt - b[1].lastAccessedAt;\n      });\n\n    let freed = 0;\n    for (const [key, entry] of entries) {\n      if (freed >= tokensNeeded) break;\n      this.cache.delete(key);\n      this.stats.evictions++;\n      freed += entry.tokenCount;\n      this.emitEvent('evict', entry.bucket, key, true, entry.tokenCount, `Global LRU eviction (total capacity pressure)`);\n    }\n  }\n\n  private emitEvent(\n    operation: 'store' | 'retrieve' | 'evict' | 'expire',\n    bucket: 'transient' | 'decision' | 'sensitive',\n    key: string,\n    success: boolean,\n    tokensAffected: number,\n    evictionReason?: string\n  ): void {\n    const totalCacheTokens = Array.from(this.cache.values()).reduce((sum, e) => sum + e.tokenCount, 0);\n    const event: CacheEvent = {\n      timestamp: Date.now(),\n      operation,\n      bucket,\n      key,\n      success,\n      tokensAffected,\n      totalCacheTokens,\n      evictionReason,\n    };\n\n    this.eventLog.push(event);\n\n    // Keep event log bounded (last 10k events)\n    if (this.eventLog.length > 10000) {\n      this.eventLog.shift();\n    }\n\n    // Console logging for dev visibility\n    if (!success || operation === 'evict' || operation === 'expire') {\n      console.log(`[Cache ${operation}]`, {\n        bucket,\n        key,\n        success,\n        tokensAffected,\n        totalCache: totalCacheTokens,\n        reason: evictionReason,\n      });\n    }\n  }\n}\n",
      "appliedAt": null,
      "validatedAt": null,
      "status": "failed",
      "validationError": "src/memory/shared-cache.ts(347,7): error TS2322: Type 'unknown' is not assignable to type 'number'.\r\nsrc/memory/shared-cache.ts(348,21): error TS18046: 'sum' is of type 'unknown'.\r\n"
    },
    {
      "file": "src/memory/shared-cache.ts",
      "action": "edit",
      "content": "/**\n * SharedMemoryCache: Three-bucket LRU cache with token awareness\n * Purpose: Shared context across agent runs, prevent memory overflow\n * Design: transient/decision/sensitive buckets, LRU eviction, TTL per bucket\n */\n\nexport interface CacheEvent {\n  timestamp: number;\n  operation: 'store' | 'retrieve' | 'evict' | 'expire';\n  bucket: 'transient' | 'decision' | 'sensitive';\n  key: string;\n  tokenCount: number;\n  totalCacheTokens: number;\n  evictionReason?: string;\n}\n\ninterface CacheEntry {\n  value: string;\n  bucket: 'transient' | 'decision' | 'sensitive';\n  createdAt: number;\n  lastAccessedAt: number;\n  reason?: string;\n  tokenCount: number;\n}\n\ninterface BucketConfig {\n  maxTokens: number;\n  ttlMs: number;\n}\n\nexport class SharedMemoryCache {\n  private cache: Map<string, CacheEntry> = new Map();\n  private eventEmitter: ((event: CacheEvent) => void) | null = null;\n\n  // Token allocation: 50k total, 10% sensitive (5k), 45k split decision/transient\n  private bucketConfigs: Record<'transient' | 'decision' | 'sensitive', BucketConfig> = {\n    transient: { maxTokens: 22500, ttlMs: 1 * 60 * 60 * 1000 }, // 1 hour\n    decision: { maxTokens: 22500, ttlMs: 24 * 60 * 60 * 1000 }, // 24 hours\n    sensitive: { maxTokens: 5000, ttlMs: 7 * 24 * 60 * 60 * 1000 }, // 7 days\n  };\n\n  private readonly HARD_CAP_TOKENS = 50000;\n  private readonly CHARS_PER_TOKEN = 4; // Conservative estimate\n\n  constructor(eventEmitter?: (event: CacheEvent) => void) {\n    this.eventEmitter = eventEmitter || null;\n  }\n\n  /**\n   * Store a value in the cache with bucket classification\n   * @param key Cache key\n   * @param value Content to store\n   * @param bucket Classification: transient/decision/sensitive\n   * @param reason Optional documentation field (read-only, never used for eviction)\n   */\n  store(key: string, value: string, bucket: 'transient' | 'decision' | 'sensitive', reason?: string): void {\n    const tokenCount = this.estimateTokens(value);\n\n    // HARDENING: Validate bucket allocation before accepting write\n    const bucketUsage = this.getBucketTokenUsage(bucket);\n    if (bucketUsage + tokenCount > this.bucketConfigs[bucket].maxTokens) {\n      // Evict from this bucket first before accepting new data\n      this.evictFromBucket(bucket, tokenCount);\n    }\n\n    // Remove old entry if exists (to get accurate accounting)\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    }\n\n    // Store new entry\n    const entry: CacheEntry = {\n      value,\n      bucket,\n      createdAt: Date.now(),\n      lastAccessedAt: Date.now(),\n      reason, // Documentation only - never used in eviction logic\n      tokenCount,\n    };\n    this.cache.set(key, entry);\n\n    // Emit event\n    this.emitEvent({\n      timestamp: Date.now(),\n      operation: 'store',\n      bucket,\n      key,\n      tokenCount,\n      totalCacheTokens: this.getTotalCacheTokens(),\n    });\n\n    // Check hard cap and evict if needed\n    if (this.getTotalCacheTokens() > this.HARD_CAP_TOKENS) {\n      this.evictToCapacity();\n    }\n  }\n\n  /**\n   * Retrieve a value from cache\n   * Automatically handles expiration based on bucket TTL\n   */\n  retrieve(key: string): string | null {\n    const entry = this.cache.get(key);\n\n    if (!entry) {\n      this.emitEvent({\n        timestamp: Date.now(),\n        operation: 'retrieve',\n        bucket: 'transient',\n        key,\n        tokenCount: 0,\n        totalCacheTokens: this.getTotalCacheTokens(),\n      });\n      return null;\n    }\n\n    // Check TTL expiration\n    const age = Date.now() - entry.createdAt;\n    const ttl = this.bucketConfigs[entry.bucket].ttlMs;\n\n    if (age > ttl) {\n      // Expired - remove and log\n      this.cache.delete(key);\n      this.emitEvent({\n        timestamp: Date.now(),\n        operation: 'expire',\n        bucket: entry.bucket,\n        key,\n        tokenCount: entry.tokenCount,\n        totalCacheTokens: this.getTotalCacheTokens(),\n        evictionReason: 'TTL expired',\n      });\n      return null;\n    }\n\n    // Update access time for LRU\n    entry.lastAccessedAt = Date.now();\n\n    this.emitEvent({\n      timestamp: Date.now(),\n      operation: 'retrieve',\n      bucket: entry.bucket,\n      key,\n      tokenCount: entry.tokenCount,\n      totalCacheTokens: this.getTotalCacheTokens(),\n    });\n\n    return entry.value;\n  }\n\n  /**\n   * Explicitly evict a key from cache\n   */\n  evict(key: string): void {\n    const entry = this.cache.get(key);\n    if (!entry) return;\n\n    this.cache.delete(key);\n    this.emitEvent({\n      timestamp: Date.now(),\n      operation: 'evict',\n      bucket: entry.bucket,\n      key,\n      tokenCount: entry.tokenCount,\n      totalCacheTokens: this.getTotalCacheTokens(),\n      evictionReason: 'explicit eviction',\n    });\n  }\n\n  /**\n   * Get cache statistics for monitoring\n   */\n  getStats() {\n    const stats = {\n      totalTokens: this.getTotalCacheTokens(),\n      hardCapTokens: this.HARD_CAP_TOKENS,\n      buckets: {\n        transient: {\n          tokens: this.getBucketTokenUsage('transient'),\n          maxTokens: this.bucketConfigs.transient.maxTokens,\n          entries: this.getBucketEntries('transient'),\n          ttlMs: this.bucketConfigs.transient.ttlMs,\n        },\n        decision: {\n          tokens: this.getBucketTokenUsage('decision'),\n          maxTokens: this.bucketConfigs.decision.maxTokens,\n          entries: this.getBucketEntries('decision'),\n          ttlMs: this.bucketConfigs.decision.ttlMs,\n        },\n        sensitive: {\n          tokens: this.getBucketTokenUsage('sensitive'),\n          maxTokens: this.bucketConfigs.sensitive.maxTokens,\n          entries: this.getBucketEntries('sensitive'),\n          ttlMs: this.bucketConfigs.sensitive.ttlMs,\n          // HARDENING: Explicit note - sensitive never auto-evicts\n          autoEvict: false,\n        },\n      },\n      totalEntries: this.cache.size,\n    };\n    return stats;\n  }\n\n  // ============ Private Helpers ============\n\n  private estimateTokens(value: string): number {\n    return Math.ceil(value.length / this.CHARS_PER_TOKEN);\n  }\n\n  private getTotalCacheTokens(): number {\n    return Array.from(this.cache.values()).reduce((sum, entry) => sum + entry.tokenCount, 0);\n  }\n\n  private getBucketTokenUsage(bucket: 'transient' | 'decision' | 'sensitive'): number {\n    return Array.from(this.cache.values())\n      .filter((entry) => entry.bucket === bucket)\n      .reduce((sum, entry) => sum + entry.tokenCount, 0);\n  }\n\n  private getBucketEntries(bucket: 'transient' | 'decision' | 'sensitive'): number {\n    return Array.from(this.cache.values()).filter((entry) => entry.bucket === bucket).length;\n  }\n\n  /**\n   * Evict LRU entries from specified bucket to make room\n   * HARDENING: Sensitive bucket never auto-evicts\n   */\n  private evictFromBucket(\n    bucket: 'transient' | 'decision' | 'sensitive',\n    neededTokens: number\n  ): void {\n    // NEVER auto-evict from sensitive bucket - hard stop\n    if (bucket === 'sensitive') {\n      throw new Error(\n        `Sensitive bucket at capacity (${this.getBucketTokenUsage('sensitive')} / ${this.bucketConfigs.sensitive.maxTokens} tokens). Cannot auto-evict from sensitive bucket.`\n      );\n    }\n\n    // Sort by least recently used\n    const bucketEntries = Array.from(this.cache.entries())\n      .filter(([_, entry]) => entry.bucket === bucket)\n      .sort(([_, a], [__, b]) => a.lastAccessedAt - b.lastAccessedAt);\n\n    let freedTokens = 0;\n    for (const [key, entry] of bucketEntries) {\n      if (freedTokens >= neededTokens) break;\n      this.cache.delete(key);\n      freedTokens += entry.tokenCount;\n      this.emitEvent({\n        timestamp: Date.now(),\n        operation: 'evict',\n        bucket: entry.bucket,\n        key,\n        tokenCount: entry.tokenCount,\n        totalCacheTokens: this.getTotalCacheTokens(),\n        evictionReason: `bucket overflow (needed ${neededTokens} tokens)`,\n      });\n    }\n  }\n\n  /**\n   * Evict down to hard cap if exceeded\n   * Order: own bucket (LRU) → decision (LRU) → transient (LRU)\n   * NEVER sensitive\n   */\n  private evictToCapacity(): void {\n    const excess = this.getTotalCacheTokens() - this.HARD_CAP_TOKENS;\n    if (excess <= 0) return;\n\n    // Collect all evictable entries sorted by LRU across buckets\n    const evictable = Array.from(this.cache.entries())\n      .filter(([_, entry]) => entry.bucket !== 'sensitive') // HARDENING: never evict sensitive\n      .sort(([_, a], [__, b]) => {\n        // Decision bucket first (longer TTL), then transient\n        if (a.bucket === 'decision' && b.bucket === 'transient') return 1;\n        if (a.bucket === 'transient' && b.bucket === 'decision') return -1;\n        // Within same bucket, LRU\n        return a.lastAccessedAt - b.lastAccessedAt;\n      });\n\n    let freedTokens = 0;\n    for (const [key, entry] of evictable) {\n      if (freedTokens >= excess) break;\n      this.cache.delete(key);\n      freedTokens += entry.tokenCount;\n      this.emitEvent({\n        timestamp: Date.now(),\n        operation: 'evict',\n        bucket: entry.bucket,\n        key,\n        tokenCount: entry.tokenCount,\n        totalCacheTokens: this.getTotalCacheTokens(),\n        evictionReason: `hard cap overflow (excess: ${excess} tokens)`,\n      });\n    }\n  }\n\n  private emitEvent(event: CacheEvent): void {\n    if (this.eventEmitter) {\n      this.eventEmitter(event);\n    }\n    // Fallback: always log for visibility\n    console.log(\n      `[SharedMemoryCache] ${event.operation.toUpperCase()} | bucket=${event.bucket} | key=${event.key} | tokens=${event.tokenCount} | total=${event.totalCacheTokens}${event.evictionReason ? ` | reason=${event.evictionReason}` : ''}`\n    );\n  }\n}\n",
      "appliedAt": null,
      "validatedAt": null,
      "status": "failed",
      "validationError": "src/memory/shared-cache.ts(347,7): error TS2322: Type 'unknown' is not assignable to type 'number'.\r\nsrc/memory/shared-cache.ts(348,21): error TS18046: 'sum' is of type 'unknown'.\r\n"
    },
    {
      "file": "src/memory/shared-cache.ts",
      "action": "edit",
      "content": "/**\n * SharedMemoryCache: Three-bucket LRU cache with token awareness\n * Purpose: Help agents share context across runs, prevent memory overflow\n * \n * Design constraints (ENFORCED IN CODE):\n * - Reason field is documentation-only, NEVER used in eviction logic\n * - Sensitive bucket NEVER auto-evicts (hard stop)\n * - 50k token hard cap total, 10% (~5k) reserved for sensitive\n * - TTL checking at access time (no background tasks)\n * - Every operation logged for observability\n */\n\nimport { EventEmitter } from 'events';\n\ntype BucketType = 'transient' | 'decision' | 'sensitive';\n\ninterface CacheEntry {\n  value: string;\n  bucket: BucketType;\n  tokens: number;\n  createdAt: number;\n  lastAccessedAt: number;\n  reason?: string; // Documentation only, never used in logic\n}\n\ninterface CacheEvent {\n  timestamp: number;\n  operation: 'store' | 'retrieve' | 'evict' | 'expire' | 'reject';\n  bucket: BucketType;\n  key: string;\n  tokenCount: number;\n  totalCacheTokens: number;\n  reason?: string; // Why eviction happened (if applicable)\n  error?: string; // Error context (if applicable)\n}\n\ninterface CacheStats {\n  totalTokens: number;\n  bucketBreakdown: {\n    transient: { tokens: number; entries: number };\n    decision: { tokens: number; entries: number };\n    sensitive: { tokens: number; entries: number };\n  };\n  hitRate: number;\n  evictionCount: number;\n}\n\nexport class SharedMemoryCache extends EventEmitter {\n  private cache: Map<string, CacheEntry> = new Map();\n  private eventEmitter = new EventEmitter();\n\n  // Configuration per spec\n  private readonly MAX_TOTAL_TOKENS = 50_000;\n  private readonly SENSITIVE_MAX_TOKENS = 5_000; // 10% of total\n  private readonly TTL_MS = {\n    transient: 1000 * 60 * 5, // 5 minutes\n    decision: 1000 * 60 * 60, // 1 hour\n    sensitive: 1000 * 60 * 60 * 24, // 24 hours\n  };\n\n  // Observability\n  private stats = {\n    hits: 0,\n    misses: 0,\n    evictions: 0,\n  };\n\n  constructor() {\n    super();\n  }\n\n  /**\n   * Store a value in the cache\n   * Triggers eviction if capacity exceeded\n   */\n  store(key: string, value: string, bucket: BucketType, reason?: string): void {\n    const tokens = this.estimateTokens(value);\n    const now = Date.now();\n\n    // Check if adding this entry would exceed sensitive bucket limit\n    if (bucket === 'sensitive') {\n      const sensitiveTokens = this.getBucketTokens('sensitive');\n      if (sensitiveTokens + tokens > this.SENSITIVE_MAX_TOKENS) {\n        // NEVER auto-evict from sensitive bucket (hard stop)\n        const event: CacheEvent = {\n          timestamp: now,\n          operation: 'reject',\n          bucket,\n          key,\n          tokenCount: tokens,\n          totalCacheTokens: this.getTotalTokens(),\n          reason: 'Sensitive bucket capacity exceeded, rejecting store',\n          error: `Cannot store ${tokens} tokens in sensitive bucket (max ${this.SENSITIVE_MAX_TOKENS})`,\n        };\n        this.emitEvent(event);\n        return;\n      }\n    }\n\n    // Check total capacity and evict if needed\n    const totalTokens = this.getTotalTokens();\n    if (totalTokens + tokens > this.MAX_TOTAL_TOKENS) {\n      this.evictToMakeSpace(tokens, bucket);\n    }\n\n    // Store the entry\n    this.cache.set(key, {\n      value,\n      bucket,\n      tokens,\n      createdAt: now,\n      lastAccessedAt: now,\n      reason, // Documentation only\n    });\n\n    const event: CacheEvent = {\n      timestamp: now,\n      operation: 'store',\n      bucket,\n      key,\n      tokenCount: tokens,\n      totalCacheTokens: this.getTotalTokens(),\n      reason, // Log the documentation reason\n    };\n    this.emitEvent(event);\n  }\n\n  /**\n   * Retrieve a value from the cache\n   * Returns null if not found or expired\n   * Updates last accessed time for LRU\n   */\n  retrieve(key: string): string | null {\n    const now = Date.now();\n    const entry = this.cache.get(key);\n\n    if (!entry) {\n      this.stats.misses++;\n      return null;\n    }\n\n    // Check if expired\n    if (now - entry.createdAt > this.TTL_MS[entry.bucket]) {\n      this.cache.delete(key);\n      const event: CacheEvent = {\n        timestamp: now,\n        operation: 'expire',\n        bucket: entry.bucket,\n        key,\n        tokenCount: entry.tokens,\n        totalCacheTokens: this.getTotalTokens(),\n        reason: `TTL exceeded for ${entry.bucket} bucket`,\n      };\n      this.emitEvent(event);\n      this.stats.misses++;\n      return null;\n    }\n\n    // Hit: update access time for LRU\n    entry.lastAccessedAt = now;\n    this.stats.hits++;\n\n    const event: CacheEvent = {\n      timestamp: now,\n      operation: 'retrieve',\n      bucket: entry.bucket,\n      key,\n      tokenCount: entry.tokens,\n      totalCacheTokens: this.getTotalTokens(),\n    };\n    this.emitEvent(event);\n\n    return entry.value;\n  }\n\n  /**\n   * Manually evict a key\n   */\n  evict(key: string): void {\n    const entry = this.cache.get(key);\n    if (!entry) return;\n\n    this.cache.delete(key);\n    this.stats.evictions++;\n\n    const event: CacheEvent = {\n      timestamp: Date.now(),\n      operation: 'evict',\n      bucket: entry.bucket,\n      key,\n      tokenCount: entry.tokens,\n      totalCacheTokens: this.getTotalTokens(),\n      reason: 'Manual eviction',\n    };\n    this.emitEvent(event);\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getStats(): CacheStats {\n    const breakdown = {\n      transient: { tokens: 0, entries: 0 },\n      decision: { tokens: 0, entries: 0 },\n      sensitive: { tokens: 0, entries: 0 },\n    };\n\n    this.cache.forEach((entry) => {\n      breakdown[entry.bucket].tokens += entry.tokens;\n      breakdown[entry.bucket].entries += 1;\n    });\n\n    const totalAccess = this.stats.hits + this.stats.misses;\n    const hitRate = totalAccess > 0 ? this.stats.hits / totalAccess : 0;\n\n    return {\n      totalTokens: this.getTotalTokens(),\n      bucketBreakdown: breakdown,\n      hitRate,\n      evictionCount: this.stats.evictions,\n    };\n  }\n\n  /**\n   * Register listener for cache events (for external logging integration)\n   */\n  onCacheEvent(callback: (event: CacheEvent) => void): void {\n    this.eventEmitter.on('cacheEvent', callback);\n  }\n\n  // ========== PRIVATE HELPERS ==========\n\n  private emitEvent(event: CacheEvent): void {\n    // Emit for external listeners (monitoring, logging)\n    this.eventEmitter.emit('cacheEvent', event);\n    // Fallback console logging for dev visibility\n    console.log(`[Cache ${event.operation.toUpperCase()}]`, {\n      bucket: event.bucket,\n      key: event.key,\n      tokens: event.tokenCount,\n      totalTokens: event.totalCacheTokens,\n      reason: event.reason,\n      error: event.error,\n      timestamp: new Date(event.timestamp).toISOString(),\n    });\n  }\n\n  private estimateTokens(value: string): number {\n    // Conservative estimate: 4 characters per token\n    return Math.ceil(value.length / 4);\n  }\n\n  private getTotalTokens(): number {\n    let total = 0;\n    this.cache.forEach((entry) => {\n      total += entry.tokens;\n    });\n    return total;\n  }\n\n  private getBucketTokens(bucket: BucketType): number {\n    let total = 0;\n    this.cache.forEach((entry) => {\n      if (entry.bucket === bucket) {\n        total += entry.tokens;\n      }\n    });\n    return total;\n  }\n\n  /**\n   * Evict entries to make space for new entry\n   * Order: own bucket LRU → decision bucket LRU → transient bucket LRU\n   * NEVER evict from sensitive bucket\n   */\n  private evictToMakeSpace(neededTokens: number, newBucket: BucketType): void {\n    const evictionOrder: BucketType[] = (\n      newBucket === 'sensitive'\n        ? ['sensitive', 'decision', 'transient'] // Should never evict sensitive, but ordering matters\n        : newBucket === 'decision'\n          ? ['decision', 'transient']\n          : ['transient', 'decision']\n    );\n\n    let freedTokens = 0;\n    for (const bucket of evictionOrder) {\n      if (bucket === 'sensitive') {\n        // NEVER auto-evict from sensitive bucket (hard stop)\n        continue;\n      }\n\n      const entries = Array.from(this.cache.entries())\n        .filter(([, entry]) => entry.bucket === bucket)\n        .sort(([, a], [, b]) => a.lastAccessedAt - b.lastAccessedAt); // LRU\n\n      for (const [key, entry] of entries) {\n        if (freedTokens >= neededTokens) break;\n        this.cache.delete(key);\n        freedTokens += entry.tokens;\n        this.stats.evictions++;\n\n        const event: CacheEvent = {\n          timestamp: Date.now(),\n          operation: 'evict',\n          bucket: entry.bucket,\n          key,\n          tokenCount: entry.tokens,\n          totalCacheTokens: this.getTotalTokens(),\n          reason: `LRU eviction in ${bucket} bucket to make space for ${newBucket}`,\n        };\n        this.emitEvent(event);\n      }\n\n      if (freedTokens >= neededTokens) break;\n    }\n  }\n}\n",
      "appliedAt": null,
      "validatedAt": null,
      "status": "failed",
      "validationError": "src/memory/shared-cache.ts(347,7): error TS2322: Type 'unknown' is not assignable to type 'number'.\r\nsrc/memory/shared-cache.ts(348,21): error TS18046: 'sum' is of type 'unknown'.\r\n"
    },
    {
      "file": "src/memory/shared-cache.ts",
      "action": "edit",
      "content": "/**\n * SharedMemoryCache: Three-bucket LRU cache for agent context sharing\n * - Transient (default TTL: 1 hour): temporary conversation state\n * - Decision (default TTL: 24 hours): important decisions and outcomes\n * - Sensitive (default TTL: 7 days, 10% of capacity, NO auto-eviction): PII, secrets, guardrails\n * - Hard cap: 50k tokens total\n * - Token estimation: conservative 4 chars per token\n */\n\nexport type BucketType = 'transient' | 'decision' | 'sensitive';\n\nexport interface CacheEntry {\n  key: string;\n  value: string;\n  bucket: BucketType;\n  storedAt: number;\n  lastAccessedAt: number;\n  expiresAt: number;\n  tokens: number;\n  reason?: string; // Documentation only - NEVER used in eviction logic\n}\n\nexport interface CacheEvent {\n  timestamp: number;\n  operation: 'store' | 'retrieve' | 'evict' | 'expire';\n  bucket: BucketType;\n  key: string;\n  tokens: number;\n  totalCacheTokens: number;\n  evictionReason?: string;\n  success: boolean;\n  error?: string;\n}\n\nexport interface CacheStats {\n  totalTokens: number;\n  entriesByBucket: Record<BucketType, number>;\n  tokensByBucket: Record<BucketType, number>;\n  capacityByBucket: Record<BucketType, number>;\n}\n\ntype EventEmitter = (event: CacheEvent) => void;\n\nexport class SharedMemoryCache {\n  private entries: Map<string, CacheEntry> = new Map();\n  private accessOrder: Map<string, number> = new Map(); // key -> lastAccessTime\n  private eventEmitter: EventEmitter | null = null;\n\n  // Configuration (in tokens)\n  private readonly HARD_CAP_TOKENS = 50000;\n  private readonly SENSITIVE_PERCENT = 0.1;\n  private readonly BUCKET_CAPS: Record<BucketType, number> = {\n    sensitive: Math.floor(this.HARD_CAP_TOKENS * this.SENSITIVE_PERCENT),\n    decision: Math.floor(this.HARD_CAP_TOKENS * 0.45),\n    transient: Math.floor(this.HARD_CAP_TOKENS * 0.45),\n  };\n\n  // TTLs in milliseconds\n  private readonly DEFAULT_TTLS: Record<BucketType, number> = {\n    transient: 1 * 60 * 60 * 1000, // 1 hour\n    decision: 24 * 60 * 60 * 1000, // 24 hours\n    sensitive: 7 * 24 * 60 * 60 * 1000, // 7 days\n  };\n\n  constructor(eventEmitter?: EventEmitter) {\n    this.eventEmitter = eventEmitter || null;\n  }\n\n  /**\n   * Store a value in the cache with optional documentation reason.\n   * Reason field is NEVER used in eviction decisions (safety guarantee).\n   */\n  public store(\n    key: string,\n    value: string,\n    bucket: BucketType = 'transient',\n    reason?: string\n  ): boolean {\n    const tokens = this.estimateTokens(value);\n    const now = Date.now();\n    const expiresAt = now + this.DEFAULT_TTLS[bucket];\n\n    // Safety check: hard bucket cap enforcement BEFORE eviction\n    const bucketUsage = this.getBucketTokens(bucket);\n    if (bucketUsage + tokens > this.BUCKET_CAPS[bucket]) {\n      // NEVER auto-evict from sensitive bucket\n      if (bucket === 'sensitive') {\n        this.emit({\n          timestamp: now,\n          operation: 'store',\n          bucket,\n          key,\n          tokens,\n          totalCacheTokens: this.getTotalTokens(),\n          success: false,\n          error: 'Sensitive bucket capacity exceeded - refusing store (no auto-evict)',\n        });\n        return false;\n      }\n\n      // For other buckets: evict LRU entries\n      this.evictLRU(bucket, tokens);\n    }\n\n    // Remove old entry if exists\n    const oldEntry = this.entries.get(key);\n    if (oldEntry) {\n      // Update access time, overwrite value\n      oldEntry.value = value;\n      oldEntry.storedAt = now;\n      oldEntry.lastAccessedAt = now;\n      oldEntry.expiresAt = expiresAt;\n      oldEntry.tokens = tokens;\n      oldEntry.reason = reason;\n    } else {\n      // New entry\n      this.entries.set(key, {\n        key,\n        value,\n        bucket,\n        storedAt: now,\n        lastAccessedAt: now,\n        expiresAt,\n        tokens,\n        reason,\n      });\n    }\n\n    this.accessOrder.set(key, now);\n\n    this.emit({\n      timestamp: now,\n      operation: 'store',\n      bucket,\n      key,\n      tokens,\n      totalCacheTokens: this.getTotalTokens(),\n      success: true,\n    });\n\n    return true;\n  }\n\n  /**\n   * Retrieve a value from cache.\n   * Expired entries are evicted at access time (no background task).\n   */\n  public retrieve(key: string): string | null {\n    const now = Date.now();\n    const entry = this.entries.get(key);\n\n    if (!entry) {\n      this.emit({\n        timestamp: now,\n        operation: 'retrieve',\n        bucket: 'transient',\n        key,\n        tokens: 0,\n        totalCacheTokens: this.getTotalTokens(),\n        success: false,\n        error: 'Key not found',\n      });\n      return null;\n    }\n\n    // Check expiration\n    if (now > entry.expiresAt) {\n      this.entries.delete(key);\n      this.accessOrder.delete(key);\n\n      this.emit({\n        timestamp: now,\n        operation: 'expire',\n        bucket: entry.bucket,\n        key,\n        tokens: entry.tokens,\n        totalCacheTokens: this.getTotalTokens(),\n        success: true,\n        evictionReason: 'TTL expired',\n      });\n\n      return null;\n    }\n\n    // Update access time\n    entry.lastAccessedAt = now;\n    this.accessOrder.set(key, now);\n\n    this.emit({\n      timestamp: now,\n      operation: 'retrieve',\n      bucket: entry.bucket,\n      key,\n      tokens: entry.tokens,\n      totalCacheTokens: this.getTotalTokens(),\n      success: true,\n    });\n\n    return entry.value;\n  }\n\n  /**\n   * Manually evict a key from the cache.\n   */\n  public evict(key: string): boolean {\n    const now = Date.now();\n    const entry = this.entries.get(key);\n\n    if (!entry) {\n      return false;\n    }\n\n    this.entries.delete(key);\n    this.accessOrder.delete(key);\n\n    this.emit({\n      timestamp: now,\n      operation: 'evict',\n      bucket: entry.bucket,\n      key,\n      tokens: entry.tokens,\n      totalCacheTokens: this.getTotalTokens(),\n      success: true,\n      evictionReason: 'Manual eviction',\n    });\n\n    return true;\n  }\n\n  /**\n   * Get current cache statistics.\n   */\n  public getStats(): CacheStats {\n    const stats: CacheStats = {\n      totalTokens: 0,\n      entriesByBucket: { transient: 0, decision: 0, sensitive: 0 },\n      tokensByBucket: { transient: 0, decision: 0, sensitive: 0 },\n      capacityByBucket: { ...this.BUCKET_CAPS },\n    };\n\n    for (const entry of this.entries.values()) {\n      stats.entriesByBucket[entry.bucket]++;\n      stats.tokensByBucket[entry.bucket] += entry.tokens;\n      stats.totalTokens += entry.tokens;\n    }\n\n    return stats;\n  }\n\n  /**\n   * Set a custom event emitter for observability integration.\n   */\n  public setEventEmitter(emitter: EventEmitter): void {\n    this.eventEmitter = emitter;\n  }\n\n  // ============ PRIVATE HELPERS ============\n\n  /**\n   * Estimate tokens conservatively: 4 characters per token.\n   */\n  private estimateTokens(value: string): number {\n    return Math.ceil(value.length / 4);\n  }\n\n  /**\n   * Get total tokens currently in cache.\n   */\n  private getTotalTokens(): number {\n    let total = 0;\n    for (const entry of this.entries.values()) {\n      total += entry.tokens;\n    }\n    return total;\n  }\n\n  /**\n   * Get tokens used by a specific bucket.\n   */\n  private getBucketTokens(bucket: BucketType): number {\n    let total = 0;\n    for (const entry of this.entries.values()) {\n      if (entry.bucket === bucket) {\n        total += entry.tokens;\n      }\n    }\n    return total;\n  }\n\n  /**\n   * Evict LRU entries from bucket to make space.\n   * Order: own bucket → decision → transient (NEVER sensitive)\n   */\n  private evictLRU(bucket: BucketType, targetTokens: number): void {\n    let freed = 0;\n    const now = Date.now();\n\n    // Phase 1: Evict LRU from the requesting bucket\n    const bucketsToEvict: BucketType[] =\n      bucket === 'sensitive'\n        ? [] // NEVER auto-evict sensitive\n        : bucket === 'decision'\n          ? ['decision', 'transient']\n          : ['transient', 'decision'];\n\n    for (const evictBucket of bucketsToEvict) {\n      if (freed >= targetTokens) break;\n\n      // NEVER evict sensitive bucket\n      if (evictBucket === 'sensitive') continue;\n\n      const candidates = Array.from(this.entries.values())\n        .filter((e) => e.bucket === evictBucket)\n        .sort((a, b) => a.lastAccessedAt - b.lastAccessedAt);\n\n      for (const candidate of candidates) {\n        if (freed >= targetTokens) break;\n\n        this.entries.delete(candidate.key);\n        this.accessOrder.delete(candidate.key);\n        freed += candidate.tokens;\n\n        this.emit({\n          timestamp: now,\n          operation: 'evict',\n          bucket: candidate.bucket,\n          key: candidate.key,\n          tokens: candidate.tokens,\n          totalCacheTokens: this.getTotalTokens(),\n          success: true,\n          evictionReason: `LRU eviction (freed ${freed}/${targetTokens} tokens)`,\n        });\n      }\n    }\n  }\n\n  /**\n   * Emit a structured cache event for observability.\n   */\n  private emit(event: CacheEvent): void {\n    if (this.eventEmitter) {\n      this.eventEmitter(event);\n    } else {\n      // Fallback: console logging for dev visibility\n      console.log(\n        `[CacheEvent] ${event.operation.toUpperCase()} ${event.bucket}:${event.key} (${event.tokens}t, total: ${event.totalCacheTokens}t)${\n          event.error ? ` ERROR: ${event.error}` : ''\n        }${\n          event.evictionReason ? ` - ${event.evictionReason}` : ''\n        }`\n      );\n    }\n  }\n}\n",
      "appliedAt": null,
      "validatedAt": null,
      "status": "failed",
      "validationError": "src/memory/shared-cache.ts(347,7): error TS2322: Type 'unknown' is not assignable to type 'number'.\r\nsrc/memory/shared-cache.ts(348,21): error TS18046: 'sum' is of type 'unknown'.\r\n"
    },
    {
      "file": "src/memory/shared-cache.ts",
      "action": "edit",
      "content": "/**\n * SharedMemoryCache: Three-bucket LRU cache for agent context sharing\n * - Transient: 70% of 50k = 35k tokens, TTL 1 hour\n * - Decision: 20% of 50k = 10k tokens, TTL 24 hours\n * - Sensitive: 10% of 50k = 5k tokens, NEVER auto-evicts, TTL 7 days\n * \n * All operations emit CacheEvent for observability.\n * Token estimation: conservative 4 chars per token.\n * Reason field is documentation-only, never used in eviction logic.\n */\n\ntype BucketType = 'transient' | 'decision' | 'sensitive';\n\ninterface CacheEntry {\n  value: string;\n  bucket: BucketType;\n  storedAt: number;\n  accessedAt: number;\n  reason?: string;\n  tokens: number;\n}\n\ninterface CacheEvent {\n  timestamp: number;\n  operation: 'store' | 'retrieve' | 'evict' | 'expire';\n  bucket: BucketType;\n  key: string;\n  tokens?: number;\n  totalTokens: number;\n  evictionReason?: string;\n}\n\ninterface CacheStats {\n  totalTokens: number;\n  byBucket: { transient: number; decision: number; sensitive: number };\n  entryCount: number;\n  hitRate: number;\n}\n\nexport class SharedMemoryCache {\n  private entries: Map<string, CacheEntry> = new Map();\n  private eventLog: CacheEvent[] = [];\n  private hits = 0;\n  private misses = 0;\n\n  // Bucket configuration: capacity (tokens) and TTL (ms)\n  private bucketConfig = {\n    transient: { capacity: 35000, ttl: 3600000 },     // 1 hour\n    decision: { capacity: 10000, ttl: 86400000 },     // 24 hours\n    sensitive: { capacity: 5000, ttl: 604800000 }     // 7 days\n  };\n\n  private readonly HARD_CAP = 50000; // Total cache limit\n  private eventEmitter: ((event: CacheEvent) => void) | null = null;\n\n  /**\n   * Set external event handler (e.g., for logging service integration)\n   */\n  onCacheEvent(handler: (event: CacheEvent) => void): void {\n    this.eventEmitter = handler;\n  }\n\n  /**\n   * Store a value in the cache\n   * @param key Cache key\n   * @param value String value to cache\n   * @param bucket Target bucket (transient/decision/sensitive)\n   * @param reason Optional: why this value is being cached (documentation only)\n   */\n  store(key: string, value: string, bucket: BucketType, reason?: string): boolean {\n    const tokens = this.estimateTokens(value);\n\n    // Check if this would exceed sensitive bucket capacity\n    // NEVER auto-evict from sensitive bucket\n    if (bucket === 'sensitive') {\n      const sensitiveTokens = this.getTokensByBucket('sensitive');\n      if (sensitiveTokens + tokens > this.bucketConfig.sensitive.capacity) {\n        this.emitEvent({\n          timestamp: Date.now(),\n          operation: 'store',\n          bucket,\n          key,\n          tokens,\n          totalTokens: this.getTotalTokens(),\n          evictionReason: 'SENSITIVE_BUCKET_FULL_CANNOT_EVICT'\n        });\n        return false;\n      }\n    }\n\n    // Remove existing entry if present\n    if (this.entries.has(key)) {\n      this.entries.delete(key);\n    }\n\n    // Evict if necessary to stay under hard cap\n    this.ensureCapacity(tokens, bucket);\n\n    // Store entry\n    this.entries.set(key, {\n      value,\n      bucket,\n      storedAt: Date.now(),\n      accessedAt: Date.now(),\n      reason, // Documentation only\n      tokens\n    });\n\n    this.emitEvent({\n      timestamp: Date.now(),\n      operation: 'store',\n      bucket,\n      key,\n      tokens,\n      totalTokens: this.getTotalTokens()\n    });\n\n    return true;\n  }\n\n  /**\n   * Retrieve a value from cache\n   * @param key Cache key\n   * @returns Value if found and not expired, null otherwise\n   */\n  retrieve(key: string): string | null {\n    const entry = this.entries.get(key);\n\n    if (!entry) {\n      this.misses++;\n      return null;\n    }\n\n    // Check TTL\n    const age = Date.now() - entry.storedAt;\n    if (age > this.bucketConfig[entry.bucket].ttl) {\n      // Expired\n      this.entries.delete(key);\n      this.emitEvent({\n        timestamp: Date.now(),\n        operation: 'expire',\n        bucket: entry.bucket,\n        key,\n        tokens: entry.tokens,\n        totalTokens: this.getTotalTokens()\n      });\n      this.misses++;\n      return null;\n    }\n\n    // Update access time for LRU\n    entry.accessedAt = Date.now();\n    this.hits++;\n\n    this.emitEvent({\n      timestamp: Date.now(),\n      operation: 'retrieve',\n      bucket: entry.bucket,\n      key,\n      tokens: entry.tokens,\n      totalTokens: this.getTotalTokens()\n    });\n\n    return entry.value;\n  }\n\n  /**\n   * Manually evict an entry\n   * @param key Cache key\n   */\n  evict(key: string): boolean {\n    const entry = this.entries.get(key);\n    if (!entry) return false;\n\n    // NEVER evict from sensitive bucket via manual evict\n    if (entry.bucket === 'sensitive') {\n      this.emitEvent({\n        timestamp: Date.now(),\n        operation: 'evict',\n        bucket: entry.bucket,\n        key,\n        tokens: entry.tokens,\n        totalTokens: this.getTotalTokens(),\n        evictionReason: 'SENSITIVE_BUCKET_PROTECTED_FROM_MANUAL_EVICT'\n      });\n      return false;\n    }\n\n    this.entries.delete(key);\n    this.emitEvent({\n      timestamp: Date.now(),\n      operation: 'evict',\n      bucket: entry.bucket,\n      key,\n      tokens: entry.tokens,\n      totalTokens: this.getTotalTokens(),\n      evictionReason: 'MANUAL_EVICT'\n    });\n\n    return true;\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getStats(): CacheStats {\n    return {\n      totalTokens: this.getTotalTokens(),\n      byBucket: {\n        transient: this.getTokensByBucket('transient'),\n        decision: this.getTokensByBucket('decision'),\n        sensitive: this.getTokensByBucket('sensitive')\n      },\n      entryCount: this.entries.size,\n      hitRate: this.hits + this.misses === 0 ? 0 : this.hits / (this.hits + this.misses)\n    };\n  }\n\n  /**\n   * Get event log (for debugging/observability)\n   */\n  getEventLog(): CacheEvent[] {\n    return [...this.eventLog];\n  }\n\n  // ─────────────────────────────────────────────────────────────────\n  // PRIVATE IMPLEMENTATION\n  // ─────────────────────────────────────────────────────────────────\n\n  /**\n   * Estimate tokens for a value (conservative: 4 chars per token)\n   */\n  private estimateTokens(value: string): number {\n    return Math.ceil(value.length / 4);\n  }\n\n  /**\n   * Get total tokens across all buckets\n   */\n  private getTotalTokens(): number {\n    let total = 0;\n    for (const entry of this.entries.values()) {\n      total += entry.tokens;\n    }\n    return total;\n  }\n\n  /**\n   * Get tokens used by a specific bucket\n   */\n  private getTokensByBucket(bucket: BucketType): number {\n    let total = 0;\n    for (const entry of this.entries.values()) {\n      if (entry.bucket === bucket) total += entry.tokens;\n    }\n    return total;\n  }\n\n  /**\n   * Evict least recently used entries to make room\n   * Eviction order: own bucket → decision → transient (NEVER sensitive)\n   */\n  private ensureCapacity(tokensNeeded: number, targetBucket: BucketType): void {\n    let totalTokens = this.getTotalTokens();\n\n    if (totalTokens + tokensNeeded <= this.HARD_CAP) {\n      return; // Already have capacity\n    }\n\n    // Evict from target bucket first\n    this.evictLRUFromBucket(targetBucket, totalTokens + tokensNeeded - this.HARD_CAP);\n    totalTokens = this.getTotalTokens();\n\n    if (totalTokens + tokensNeeded <= this.HARD_CAP) {\n      return;\n    }\n\n    // Evict from decision bucket\n    this.evictLRUFromBucket('decision', totalTokens + tokensNeeded - this.HARD_CAP);\n    totalTokens = this.getTotalTokens();\n\n    if (totalTokens + tokensNeeded <= this.HARD_CAP) {\n      return;\n    }\n\n    // Evict from transient bucket\n    this.evictLRUFromBucket('transient', totalTokens + tokensNeeded - this.HARD_CAP);\n\n    // NEVER evict from sensitive bucket\n  }\n\n  /**\n   * Evict LRU entries from a specific bucket\n   */\n  private evictLRUFromBucket(bucket: BucketType, tokensToFree: number): void {\n    const candidates: [string, CacheEntry][] = [];\n\n    for (const [key, entry] of this.entries.entries()) {\n      if (entry.bucket === bucket) {\n        candidates.push([key, entry]);\n      }\n    }\n\n    // Sort by accessedAt (least recent first)\n    candidates.sort((a, b) => a[1].accessedAt - b[1].accessedAt);\n\n    let freed = 0;\n    for (const [key, entry] of candidates) {\n      if (freed >= tokensToFree) break;\n      this.entries.delete(key);\n      freed += entry.tokens;\n\n      this.emitEvent({\n        timestamp: Date.now(),\n        operation: 'evict',\n        bucket: entry.bucket,\n        key,\n        tokens: entry.tokens,\n        totalTokens: this.getTotalTokens(),\n        evictionReason: 'LRU_EVICTION'\n      });\n    }\n  }\n\n  /**\n   * Emit cache event to external handler and internal log\n   */\n  private emitEvent(event: CacheEvent): void {\n    this.eventLog.push(event);\n\n    // Keep log bounded (last 1000 events)\n    if (this.eventLog.length > 1000) {\n      this.eventLog.shift();\n    }\n\n    // Emit to external handler if registered\n    if (this.eventEmitter) {\n      this.eventEmitter(event);\n    }\n\n    // Dev fallback: log to console\n    console.log('[SharedMemoryCache]', {\n      operation: event.operation,\n      bucket: event.bucket,\n      key: event.key,\n      totalTokens: event.totalTokens,\n      reason: event.evictionReason\n    });\n  }\n}\n",
      "appliedAt": null,
      "validatedAt": null,
      "status": "failed",
      "validationError": "src/memory/shared-cache.ts(347,7): error TS2322: Type 'unknown' is not assignable to type 'number'.\r\nsrc/memory/shared-cache.ts(348,21): error TS18046: 'sum' is of type 'unknown'.\r\n"
    }
  ],
  "agentStates": {
    "Alex": {
      "timesProcessed": 6,
      "totalCost": 0.237293,
      "canProcess": false
    },
    "Sam": {
      "timesProcessed": 6,
      "totalCost": 0.175029,
      "canProcess": false
    },
    "Morgan": {
      "timesProcessed": 6,
      "totalCost": 0.29108300000000004,
      "canProcess": false
    },
    "Jordan": {
      "timesProcessed": 6,
      "totalCost": 0.23694,
      "canProcess": false
    },
    "Pierre": {
      "timesProcessed": 6,
      "totalCost": 0.379688,
      "canProcess": false
    }
  },
  "nextAction": {
    "type": "continue_discussion",
    "reason": "Starting fresh discussion",
    "targetAgent": "Alex"
  },
  "history": [
    {
      "runNumber": 2,
      "phase": "discussion",
      "summary": "Completed 0 cycle(s) in discussion phase",
      "cost": 0.49784599999999996,
      "timestamp": "2026-01-06T11:35:59.423Z"
    },
    {
      "runNumber": 2,
      "phase": "discussion",
      "summary": "Completed 1 cycle(s) in discussion phase",
      "cost": 0.49784599999999996,
      "timestamp": "2026-01-06T11:36:00.464Z"
    },
    {
      "runNumber": 3,
      "phase": "discussion",
      "summary": "Completed 0 cycle(s) in discussion phase",
      "cost": 0.19027399999999997,
      "timestamp": "2026-01-06T11:39:17.550Z"
    },
    {
      "runNumber": 3,
      "phase": "discussion",
      "summary": "Completed 1 cycle(s) in discussion phase",
      "cost": 0.19027399999999997,
      "timestamp": "2026-01-06T11:39:18.575Z"
    },
    {
      "runNumber": 5,
      "phase": "code_review",
      "summary": "Completed 0 cycle(s) in code_review phase",
      "cost": 0.162024,
      "timestamp": "2026-01-06T16:41:21.649Z"
    },
    {
      "runNumber": 5,
      "phase": "code_review",
      "summary": "Completed 1 cycle(s) in code_review phase",
      "cost": 0.162024,
      "timestamp": "2026-01-06T16:41:22.681Z"
    },
    {
      "runNumber": 6,
      "phase": "code_review",
      "summary": "Completed 1 cycle(s) in code_review phase",
      "cost": 0,
      "timestamp": "2026-01-06T17:02:54.339Z"
    },
    {
      "runNumber": 8,
      "phase": "code_review",
      "summary": "Completed 0 cycle(s) in code_review phase",
      "cost": 0.480707,
      "timestamp": "2026-01-06T18:06:35.883Z"
    },
    {
      "runNumber": 8,
      "phase": "code_review",
      "summary": "Completed 1 cycle(s) in code_review phase",
      "cost": 0.480707,
      "timestamp": "2026-01-06T18:06:36.917Z"
    },
    {
      "runNumber": 9,
      "phase": "code_review",
      "summary": "Completed 0 cycle(s) in code_review phase",
      "cost": 0.4870279999999999,
      "timestamp": "2026-01-06T19:55:58.500Z"
    },
    {
      "runNumber": 9,
      "phase": "code_review",
      "summary": "Completed 1 cycle(s) in code_review phase",
      "cost": 0.4870279999999999,
      "timestamp": "2026-01-06T19:55:59.592Z"
    }
  ],
  "totalCost": 3.635758,
  "humanNotes": "SUCCESS = quickly implementing something simple that compiles and affects how you work in the next round. Choosing one feature doesn't mean others won't be worked on soon - just pick a SMALL one so we get a victory in self-improvement. Your old SharedMemoryCache file is still there as reference. Stop debating endlessly - ship something tiny and iterate!"
}